MODULE main

  FROZENVAR
    n : 0..255;
    fingers1 : array 0..1 of 0..255;
    fingers2 : array 0..1 of 0..255;
    fingers3 : array 0..1 of 0..255;

  VAR
    node1 : node(10, 20, fingers1);
    node2 : node(20, 30, fingers2);
    node3 : node(30, 10, fingers3);
    index1 : -1..2;
    index2 : -1..2;
    index3 : -1..2;

  INIT
    (node1.mode = find_successor & node2.mode = waiting & node3.mode = waiting) |
    (node1.mode = waiting & node2.mode = find_successor & node3.mode = waiting) |
    (node1.mode = waiting & node2.mode = waiting & node3.mode = find_successor) ;

  ASSIGN
    init(fingers1[0]) := 20;
    init(fingers1[1]) := 30;

    init(fingers2[0]) := 30;
    init(fingers2[1]) := 10;

    init(fingers3[0]) := 10;
    init(fingers3[1]) := 20;

    init(index1) := 2;
    init(index2) := 2;
    init(index3) := 2;

    next(index1) :=
      case
        index1 = -1 : 2;
        node1.mode = get_next_finger : index1 - 1 ;
        TRUE : index1 ;
      esac;

    next(index2) :=
      case
        index2 = -1 : 2;
        node2.mode = get_next_finger : index2 - 1;
        TRUE : index2 ;
      esac;

    next(index3) :=
      case
        index3 = -1 : 2;
        node3.mode = get_next_finger : index3 - 1;
        TRUE : index3 ;
      esac;

    next(node1.mode) :=
      case

        (node1.mode = find_successor &
          (node1.id >= node1.successor_id | (node1.id < n & n <= node1.successor_id)) &
          (node1.id <  node1.successor_id | (n > node1.id | n <= node1.successor_id))) : found_successor;

        (node1.mode = find_successor & !(
          (node1.id >= node1.successor_id | (node1.id < n & n <= node1.successor_id)) &
          (node1.id <  node1.successor_id | (n > node1.id | n <= node1.successor_id)))) : closest_preceding;

        node1.mode = waiting & node2.mode = next_node & index2 = 1 : find_successor ;
        node1.mode = waiting & node3.mode = next_node & index3 = 0 : find_successor ;

        node1.mode = closest_preceding : get_next_finger ;

        node1.mode = get_next_finger & index1 >= 0 : test_finger ;
        node1.mode = get_next_finger & index1 < 0 : find_successor ;

        node1.mode = test_finger & index1 = -1 : find_successor ;

        -- Temp
        node1.mode = test_finger & index1 >= 2 : gte2 ;
        node1.mode = test_finger & index1 <= -1 : lten1 ;

        node1.mode = test_finger &
          (node1.id >= n | (node1.id < fingers1[index1] & fingers1[index1] < n)) &
          (node1.id <  n | (fingers1[index1] > node1.id | fingers1[index1] < n)) : next_node ;

        node1.mode = test_finger & !(
          (node1.id >= n | (node1.id < fingers1[index1] & fingers1[index1] < n)) &
          (node1.id <  n | (fingers1[index1] > node1.id | fingers1[index1] < n))) : get_next_finger ;

        node1.mode = next_node : waiting ;

        TRUE : node1.mode ;
      esac;

    next(node2.mode) :=
      case
        (node2.mode = find_successor &
          (node2.id >= node2.successor_id | (node2.id < n & n <= node2.successor_id)) &
          (node2.id <  node2.successor_id | (n > node2.id | n <= node2.successor_id))) : found_successor;

        (node2.mode = find_successor & !(
          (node2.id >= node2.successor_id | (node2.id < n & n <= node2.successor_id)) &
          (node2.id <  node2.successor_id | (n > node2.id | n <= node2.successor_id)))) : closest_preceding;

        node2.mode = waiting & node1.mode = next_node & index1 = 0 : find_successor;
        node2.mode = waiting & node3.mode = next_node & index3 = 1 : find_successor;

        node2.mode = closest_preceding : get_next_finger ;

        node2.mode = get_next_finger & index2 >= 0 : test_finger ;
        node2.mode = get_next_finger & index2 < 0 : find_successor ;

        node2.mode = test_finger & index2 = -1 : find_successor ;

        -- Temp
        node2.mode = test_finger & index2 >= 2 : gte2 ;
        node2.mode = test_finger & index2 <= -1 : lten1 ;

        node2.mode = test_finger &
          (node2.id >= n | (node2.id < fingers2[index2] & fingers2[index2] < n)) &
          (node2.id <  n | (fingers2[index2] > node2.id | fingers2[index2] < n)) : next_node ;

        node2.mode = test_finger & !(
          (node2.id >= n | (node2.id < fingers2[index2] & fingers2[index2] < n)) &
          (node2.id <  n | (fingers2[index2] > node2.id | fingers2[index2] < n))) : get_next_finger ;

        node2.mode = next_node : waiting ;

        TRUE : node2.mode ;
      esac;

    next(node3.mode) :=
      case
        (node3.mode = find_successor &
          (node3.id >= node3.successor_id | (node3.id < n & n <= node3.successor_id)) &
          (node3.id <  node3.successor_id | (n > node3.id | n <= node3.successor_id))) : found_successor;

        (node3.mode = find_successor & !(
          (node3.id >= node3.successor_id | (node3.id < n & n <= node3.successor_id)) &
          (node3.id <  node3.successor_id | (n > node3.id | n <= node3.successor_id)))) : closest_preceding;

        node3.mode = waiting & node1.mode = next_node & index1 = 1 : find_successor ;
        node3.mode = waiting & node2.mode = next_node & index2 = 0 : find_successor ;

        node3.mode = closest_preceding : get_next_finger ;

        node3.mode = get_next_finger & index3 >= 0 : test_finger ;
        node3.mode = get_next_finger & index3 < 0 : find_successor ;

        node3.mode = test_finger & index3 = -1 : find_successor ;

        -- Temp
        node3.mode = test_finger & index3 >= 2 : gte2 ;
        node3.mode = test_finger & index3 <= -1 : lten1 ;

        node3.mode = test_finger &
          (node3.id >= n | (node3.id < fingers3[index3] & fingers3[index3] < n)) &
          (node3.id <  n | (fingers3[index3] > node3.id | fingers3[index3] < n)) : next_node ;

        node3.mode = test_finger & !(
          (node3.id >= n | (node3.id < fingers3[index3] & fingers3[index3] < n)) &
          (node3.id <  n | (fingers3[index3] > node3.id | fingers3[index3] < n))) : get_next_finger ;

        node3.mode = next_node : waiting ;

        TRUE : node3.mode ;
      esac;

LTLSPEC
  ((G (n > 10 & n <= 20)) & (F node1.mode = found_successor)) xor
  ((G (n > 20 & n <= 30)) & (F node2.mode = found_successor)) xor
  ((G (n > 30 | n <= 10)) & (F node3.mode = found_successor));

LTLSPEC
  node1.mode = find_successor xor
  node2.mode = find_successor xor
  node3.mode = find_successor;

INVARSPEC
  (node1.mode != gte2);

INVARSPEC
  (node2.mode != gte2);

INVARSPEC
  (node3.mode != gte2);

INVARSPEC
  (node1.mode != lten1);

INVARSPEC
  (node2.mode != lten1);

INVARSPEC
  (node3.mode != lten1);

MODULE node(id_i, successor_id_i, fingers_i)

  FROZENVAR
    id : 0..255;
    successor_id : 0..255;

  VAR
    mode : {
      waiting,
      find_successor,
      found_successor,
      closest_preceding,
      get_next_finger,
      test_finger,
      next_node,
      gte2,
      lten1
    };

  DEFINE
    fingers := fingers_i;

  ASSIGN
    init(id) := id_i;
    init(successor_id) := successor_id_i;

LTLSPEC
  (F mode = find_successor) -> X (mode = found_successor | mode = closest_preceding);
